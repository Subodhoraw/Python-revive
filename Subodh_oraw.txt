==================================================
patient medical record 
==================================================

 Name : Subodh Oraw
  Age : 45
 Blood Type : o+
 Diagnosis : Type 2 Diabetes
 Medications : Metformin 500mg
 Next Appointment : 2024-12-01

==================================================
 a payment simulator with databas sqlite 
Nice — I built an **advanced payment simulator backed by SQLite** you can run locally.
It’s a small Flask app (single file) that demonstrates polymorphism for payment methods, transaction recording, refunds, fees/GST, statuses, and simple validation.

Copy the code below into a file named `app.py`, then follow the run instructions and sample `curl` commands.

---

# 1) `app.py` (single-file Flask + SQLite simulator)

```python
# app.py
import random
import time
from datetime import datetime
from enum import Enum

from flask import Flask, request, jsonify, abort
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import func

# ---------- Config ----------
APP_NAME = "PaymentSimulator"
DB_FILENAME = "sqlite:///payments.db"

app = Flask(APP_NAME)
app.config["SQLALCHEMY_DATABASE_URI"] = DB_FILENAME
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = False
db = SQLAlchemy(app)


# ---------- Utility functions ----------
def generate_transaction_id(prefix="TXN"):
    return f"{prefix}{random.randint(100000, 999999)}"


def calculate_final_amount(amount):
    """
    GST = 18% (example)
    Platform fee = ₹5 fixed
    returns (total, gst, platform_fee)
    """
    gst = round(amount * 0.18, 2)
    platform_fee = 5.0
    total = round(amount + gst + platform_fee, 2)
    return total, gst, platform_fee


# ---------- Models ----------
class PaymentStatus(Enum):
    PENDING = "PENDING"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"
    REFUNDED = "REFUNDED"


class Payment(db.Model):
    __tablename__ = "payments"

    id = db.Column(db.Integer, primary_key=True)
    txn_id = db.Column(db.String(32), unique=True, nullable=False)
    method = db.Column(db.String(32), nullable=False)  # e.g., creditcard, upi
    amount = db.Column(db.Float, nullable=False)  # original amount before gst/fees
    total_amount = db.Column(db.Float, nullable=False)  # amount charged (with gst+fees)
    gst = db.Column(db.Float, nullable=False)
    platform_fee = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(16), nullable=False, default=PaymentStatus.PENDING.value)
    created_at = db.Column(db.DateTime, server_default=func.now())
    updated_at = db.Column(db.DateTime, server_default=func.now(), onupdate=func.now())
    metadata = db.Column(db.Text, nullable=True)  # optional JSON/text metadata

    refunds = db.relationship("Refund", backref="payment", lazy=True)

    def to_dict(self):
        return {
            "id": self.id,
            "txn_id": self.txn_id,
            "method": self.method,
            "amount": self.amount,
            "total_amount": self.total_amount,
            "gst": self.gst,
            "platform_fee": self.platform_fee,
            "status": self.status,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
            "refunds": [r.to_dict() for r in self.refunds],
            "metadata": self.metadata,
        }


class Refund(db.Model):
    __tablename__ = "refunds"

    id = db.Column(db.Integer, primary_key=True)
    refund_id = db.Column(db.String(32), unique=True, nullable=False)
    payment_id = db.Column(db.Integer, db.ForeignKey("payments.id"), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    created_at = db.Column(db.DateTime, server_default=func.now())

    def to_dict(self):
        return {
            "id": self.id,
            "refund_id": self.refund_id,
            "payment_id": self.payment_id,
            "amount": self.amount,
            "created_at": self.created_at.isoformat() if self.created_at else None,
        }


# ---------- Polymorphic PaymentMethod base class & implementations ----------
class PaymentMethodBase:
    """
    Base (abstract) payment method. Child classes should override process().
    """

    def process(self, amount, metadata=None) -> dict:
        raise NotImplementedError("Child must implement process()")


class CreditCardPayment(PaymentMethodBase):
    def process(self, amount, metadata=None):
        txn = generate_transaction_id("CC")
        total, gst, fee = calculate_final_amount(amount)

        # Simulate checks: fail if random or if card limit (example)
        time.sleep(0.2)
        if amount > 200000:
            return {"status": PaymentStatus.FAILED.value, "reason": "Card limit exceeded", "txn": txn, "total": total, "gst": gst, "fee": fee}
        # otherwise success
        return {"status": PaymentStatus.SUCCESS.value, "txn": txn, "total": total, "gst": gst, "fee": fee}


class UPIPayment(PaymentMethodBase):
    def process(self, amount, metadata=None):
        txn = generate_transaction_id("UPI")
        total, gst, fee = calculate_final_amount(amount)
        # Simulate approval wait & success
        time.sleep(0.2)
        return {"status": PaymentStatus.SUCCESS.value, "txn": txn, "total": total, "gst": gst, "fee": fee}


class DebitCardPayment(PaymentMethodBase):
    def process(self, amount, metadata=None):
        txn = generate_transaction_id("DC")
        total, gst, fee = calculate_final_amount(amount)
        time.sleep(0.2)
        if amount > 50000:
            return {"status": PaymentStatus.FAILED.value, "reason": "Daily debit limit exceeded", "txn": txn, "total": total, "gst": gst, "fee": fee}
        return {"status": PaymentStatus.SUCCESS.value, "txn": txn, "total": total, "gst": gst, "fee": fee}


class CryptoPayment(PaymentMethodBase):
    def process(self, amount, metadata=None):
        txn = generate_transaction_id("CR")
        total, gst, fee = calculate_final_amount(amount)
        # Example conversion rate (INR -> USDT)
        conversion_rate = metadata.get("conversion_rate") if metadata and isinstance(metadata, dict) and metadata.get("conversion_rate") else 90.0
        usdt = round(total / conversion_rate, 6)
        time.sleep(0.2)
        return {"status": PaymentStatus.SUCCESS.value, "txn": txn, "total": total, "gst": gst, "fee": fee, "crypto_amount": usdt}


# Mapper for string -> class
PAYMENT_METHODS = {
    "creditcard": CreditCardPayment,
    "upi": UPIPayment,
    "debitcard": DebitCardPayment,
    "crypto": CryptoPayment,
}


def get_payment_handler(method_name):
    cls = PAYMENT_METHODS.get(method_name.lower())
    if cls:
        return cls()
    return None


# ---------- Routes ----------
@app.route("/")
def index():
    return jsonify({"app": APP_NAME, "time": datetime.utcnow().isoformat()})


@app.route("/pay", methods=["POST"])
def pay():
    """
    POST /pay
    JSON payload:
    {
        "method": "creditcard" | "upi" | "debitcard" | "crypto",
        "amount": 1500.50,
        "metadata": { ... }  # optional
    }
    """
    data = request.get_json() or {}
    method = data.get("method")
    amount = data.get("amount")
    metadata = data.get("metadata") or {}

    if not method or amount is None:
        return jsonify({"error": "method and amount are required"}), 400

    handler = get_payment_handler(method)
    if handler is None:
        return jsonify({"error": f"unknown payment method '{method}'"}), 400

    # Basic validation
    try:
        amount = float(amount)
        if amount <= 0:
            raise ValueError()
    except Exception:
        return jsonify({"error": "amount must be a number > 0"}), 400

    # Process the payment via polymorphic handler
    result = handler.process(amount, metadata)
    txn_id = result.get("txn")
    status = result.get("status", PaymentStatus.FAILED.value)
    total = result.get("total", 0.0)
    gst = result.get("gst", 0.0)
    fee = result.get("fee", 0.0)

    # Persist to DB
    payment = Payment(
        txn_id=txn_id or generate_transaction_id(),
        method=method.lower(),
        amount=amount,
        total_amount=total,
        gst=gst,
        platform_fee=fee,
        status=status,
        metadata=str(metadata) if metadata else None,
    )
    db.session.add(payment)
    db.session.commit()

    response = {"payment": payment.to_dict(), "note": result.get("reason") or None}
    return jsonify(response), (200 if status == PaymentStatus.SUCCESS.value else 402)


@app.route("/refund", methods=["POST"])
def refund():
    """
    POST /refund
    JSON payload:
    {
        "payment_id": 1,
        "amount": 500.0
    }
    """
    data = request.get_json() or {}
    payment_id = data.get("payment_id")
    amount = data.get("amount")

    if payment_id is None or amount is None:
        return jsonify({"error": "payment_id and amount required"}), 400

    payment = Payment.query.get(payment_id)
    if not payment:
        return jsonify({"error": "payment not found"}), 404

    try:
        amount = float(amount)
        if amount <= 0:
            raise ValueError()
    except Exception:
        return jsonify({"error": "amount must be a number > 0"}), 400

    # Can't refund more than charged
    total_refunded_so_far = sum(r.amount for r in payment.refunds) if payment.refunds else 0.0
    if (total_refunded_so_far + amount) > payment.total_amount:
        return jsonify({"error": "refund amount exceeds charged total"}), 400

    # Create refund record
    refund = Refund(
        refund_id=generate_transaction_id("RFD"),
        payment_id=payment.id,
        amount=amount,
    )
    db.session.add(refund)

    # If full refund, update payment status
    if (total_refunded_so_far + amount) == payment.total_amount:
        payment.status = PaymentStatus.REFUNDED.value
    db.session.commit()

    return jsonify({"refund": refund.to_dict(), "payment": payment.to_dict()}), 200


@app.route("/payments", methods=["GET"])
def list_payments():
    payments = Payment.query.order_by(Payment.created_at.desc()).all()
    return jsonify([p.to_dict() for p in payments])


@app.route("/payments/<int:payment_id>", methods=["GET"])
def get_payment(payment_id):
    payment = Payment.query.get(payment_id)
    if not payment:
        return jsonify({"error": "not found"}), 404
    return jsonify(payment.to_dict())


# ---------- Init / Run ----------
def init_db():
    db.create_all()


if __name__ == "__main__":
    init_db()
    app.run(debug=True, port=5000)
```

---

# 2) Requirements

Create a `requirements.txt` with:

```
Flask>=2.0
Flask-SQLAlchemy>=3.0
SQLAlchemy>=1.4
```

Install:

```bash
python -m venv venv
source venv/bin/activate      # mac/linux
# or: venv\Scripts\activate   # windows
pip install -r requirements.txt
```

---

# 3) Run the simulator

```bash
python app.py
```

App will run on `http://127.0.0.1:5000/` and create `payments.db` in the same folder.

---

# 4) Example requests (use `curl` or Postman)

### Create a payment (credit card)

```bash
curl -s -X POST http://127.0.0.1:5000/pay \
  -H "Content-Type: application/json" \
  -d '{"method":"creditcard","amount":1500,"metadata":{"card":"xxxx-xxxx-xxxx-4242"}}' | jq
```

### Create a UPI payment

```bash
curl -s -X POST http://127.0.0.1:5000/pay \
  -H "Content-Type: application/json" \
  -d '{"method":"upi","amount":999.50,"metadata":{"vpa":"user@upi"}}' | jq
```

### Create a crypto payment (pass conversion_rate in metadata)

```bash
curl -s -X POST http://127.0.0.1:5000/pay \
  -H "Content-Type: application/json" \
  -d '{"method":"crypto","amount":2500,"metadata":{"conversion_rate":92}}' | jq
```

### List all payments

```bash
curl http://127.0.0.1:5000/payments | jq
```

### Refund a payment

Assume payment `id` is 1:

```bash
curl -s -X POST http://127.0.0.1:5000/refund \
  -H "Content-Type: application/json" \
  -d '{"payment_id":1,"amount":100}' | jq
```

### Get one payment

```bash
curl http://127.0.0.1:5000/payments/1 | jq
```

---

# 5) What you get / DB schema

* `payments` table: id, txn_id, method, amount, total_amount, gst, platform_fee, status, timestamps, metadata
* `refunds` table: id, refund_id, payment_id (FK), amount, timestamp

Statuses: `PENDING`, `SUCCESS`, `FAILED`, `REFUNDED`.

Polymorphism: `PaymentMethodBase` defines `process()`. Concrete classes (`CreditCardPayment`, `UPIPayment`, `DebitCardPayment`, `CryptoPayment`) implement their logic. The Flask endpoint uses the mapping and calls `handler.process()`, then persists the results.

---

# 6) Next steps / optional upgrades (I can do any of these if you want)

* Add authentication (API keys/JWT)
* Add transaction logging and retry policies
* Add a web frontend to simulate checkout flows (simple HTML + JS)
* Add webhook simulation (notify merchant)
* Add a proper JSON metadata column (use SQLAlchemy JSON type)
* Add tests (pytest) and CI pipeline
* Turn into a Docker image + docker-compose

---

If you want, I can:

* Make this into a small **FastAPI** service (async + docs), or
* Add a **simple HTML/JS checkout simulator** that calls the endpoints, or
* Provide a **Dockerfile** and `docker-compose.yml`.

Which upgrade do you want next?
